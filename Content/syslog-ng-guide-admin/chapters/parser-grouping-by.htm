<?xml version="1.0" encoding="UTF-8"?>

 %entities;]&gt;
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd"><body name="grouping-by-parser" oldrole="section">
<h1 name="grouping-by-parser" oldrole="section">Correlating messages using the <span class="Code" oldrole="userinput">grouping-by()</span> parser</h1>
<MadCap:keyword term="correlating messages"></MadCap:keyword>
<MadCap:keyword term="correlate messages"></MadCap:keyword>
<MadCap:keyword term="parsers:['correlating']"></MadCap:keyword>
<MadCap:keyword term="parsers:['grouping-by()']"></MadCap:keyword>
<p oldrole="para">The <MadCap:variable name="General.abbrev"></MadCap:variable> application can correlate log messages that match a set of filters. This works similarly to SQL GROUP BY statements. Alternatively, you can also correlate log messages using pattern databases. For details, see <MadCap:xref href="chapter-patterndb.htm#patterndb-correlation"></MadCap:xref>.</p>
<MadCap:snippetBlock src="../../shared/chunk/correlation-intro.htm"></MadCap:snippetBlock>

<h6 oldrole="formalpara">How the grouping-by() parser works</h6>


<pre class="Code" oldrole="synopsis">
    +--------------------+
    |Incoming log message|
    +--------------------+
              |
              |
              |
              |
              V
    +-------------------------------------------+    No
    |Does it match key(), scope(), and where()? +----------&gt; Ignore message
    +-------------------------------------------+
              |
              |
              V
    Add message to context
              |
              |
              v                    No
    Is it a trigger() message or --------&gt; Wait until timeout() or a new message
    has the timeout() expired?
             +
             |
             |
             v                              No
    Does the context match having()? +-------------&gt; Close the context
            +                                         and do nothing
            |
            |
            v
    Inject the aggregate() log message and close the context
    </pre>
<p oldrole="para">The <span class="Code" oldrole="parameter">grouping-by()</span> parser has three options that determine if a message is added to a context: <span class="Code" oldrole="parameter">scope()</span>, <span class="Code" oldrole="parameter">key()</span>, and <span class="Code" oldrole="parameter">where()</span>.</p>
<ul oldrole="itemizedlist">
<li oldrole="listitem">
<p oldrole="para">The <span class="Code" oldrole="parameter">scope()</span> option acts as an early filter, selecting messages sent by the same process (<span class="Code" oldrole="userinput">${HOST}${PROGRAM}${PID}</span> is identical), application (<span class="Code" oldrole="userinput">${HOST}${PROGRAM}</span> is identical), or host.</p>
</li>
<li oldrole="listitem">
<p oldrole="para">The <span class="Code" oldrole="parameter">key()</span> identifies the context the message belongs to. (The value of the key must be the same for every message of the context.)</p>
</li>
<li oldrole="listitem">
<p oldrole="para">To use a filter to further limit the messages that are added to the context, you can use the <span class="Code" oldrole="parameter">where()</span> option.</p>
</li>
</ul>
<p oldrole="para">The <span class="Code" oldrole="parameter">timeout()</span> option determines how long a context is stored, that is, how long <MadCap:variable name="General.abbrev"></MadCap:variable> waits for related messages to arrive. If the group has a specific log message that ends the context (for example, a logout message), you can specify it using the <span class="Code" oldrole="parameter">trigger()</span> option.</p>
<p oldrole="para">When the context is closed, and the messages match the filter set in the <span class="Code" oldrole="parameter">having()</span> option (or the <span class="Code" oldrole="parameter">having()</span> option is not set), <MadCap:variable name="General.abbrev"></MadCap:variable> generates and sends the message set in the <span class="Code" oldrole="parameter">aggregate()</span> option.</p>
<MadCap:snippetBlock src="../../shared/wnt/note-message-context.htm"></MadCap:snippetBlock>

<h6 oldrole="formalpara">Declaration:</h6>


<pre class="Code" oldrole="synopsis">parser parser_name {
    grouping-by(
        key()
        having()
        aggregate()
        timeout()
    );
};</pre>
<p oldrole="para">For the parser to work, you must set at least the following options: <span class="Code" oldrole="parameter">key()</span>, <span class="Code" oldrole="parameter">aggregate()</span>, and <span class="Code" oldrole="parameter">timeout()</span>.</p>
<MadCap:snippetBlock src="../../shared/chunk/correlation-context-timeout.htm"></MadCap:snippetBlock>

<h6 oldrole="example">Example: Correlating Linux Audit logs</h6>
<p oldrole="para">Linux audit logs tend to be broken into several log messages (generated as a list of lines). Usually, the related lines are close to each other in time, but multiple events can be logged at around the same time, which get mixed up in the output. The example below is the audit log for running <b oldrole="command">ntpdate</b>:</p>
<pre class="Code" oldrole="synopsis">type=SYSCALL msg=audit(1440927434.124:40347): arch=c000003e syscall=59 success=yes exit=0 a0=7f121cef0b88 a1=7f121cef0c00 a2=7f121e690d98 a3=2 items=2 ppid=4312 pid=4347 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="ntpdate" exe="/usr/sbin/ntpdate" key=(null)
type=EXECVE msg=audit(1440927434.124:40347): argc=3 a0="/usr/sbin/ntpdate" a1="-s" a2="ntp.ubuntu.com"
type=CWD msg=audit(1440927434.124:40347):  cwd="/"
type=PATH msg=audit(1440927434.124:40347): item=0 name="/usr/sbin/ntpdate" inode=2006003 dev=08:01 mode=0100755 ouid=0 ogid=0 rdev=00:00 nametype=NORMAL
type=PATH msg=audit(1440927434.124:40347): item=1 name="/lib64/ld-linux-x86-64.so.2" inode=5243184 dev=08:01 mode=0100755 ouid=0 ogid=0 rdev=00:00 nametype=NORMAL
type=PROCTITLE msg=audit(1440927434.124:40347): proctitle=2F62696E2F7368002F7573722F7362696E2F6E7470646174652D64656269616E002D73</pre>
<p oldrole="para">These lines are connected by their second field: <span class="Code" oldrole="userinput">msg=audit(1440927434.124:40347)</span>. You can parse such messages using the <a href="parser-linux-audit.htm">Linux Audit Parser of <entity>abbrev</entity></a>, and then use the parsed <span class="Code" oldrole="userinput">.auditd.msg</span> field to group the messages.</p>
<pre class="Code" oldrole="synopsis">parser auditd_groupingby {
    grouping-by(
        key("${.auditd.msg}")
        aggregate(
            value("MESSAGE" "$(format-json .auditd.*)")
            )
        timeout(10)
    );
};</pre>
<p oldrole="para">For another example, see <a href="https://czanik.blogs.balabit.com/2016/04/the-grouping_by-parser-in-syslog-ng-3-8/">The grouping-by() parser in syslog-ng blog post</a></p>


<h2 name="referencing-previous-messages-grouping-by">Referencing earlier messages of the context</h2>
<indexterm type="parameter">
<primary>@distance</primary>
</indexterm>
<p oldrole="para">When creating the aggregated message, or in the various parameters of the <span class="Code" oldrole="parameter">grouping-by()</span> parser, you can also refer to fields and values of earlier messages of the context by adding the <span class="Code" oldrole="userinput">@&lt;distance-of-referenced-message-from-the-current&gt;</span> suffix to the macro. For example, if there are three log messages in a context, the <span class="Code" oldrole="userinput">${HOST}@1</span> expression refers to the host field of the current (third) message in the context, the <span class="Code" oldrole="userinput">${HOST}@2</span> expression refers to the host field of the previous (second) message in the context, <span class="Code" oldrole="userinput">${PID}@3</span> to the PID of the first message, and so on. For example, the following message can be created from SSH login/logout messages: <span class="Code" oldrole="userinput">An SSH session for ${SSH_USERNAME}@1 from ${SSH_CLIENT_ADDRESS}@2 closed. Session lasted from ${DATE}@2 to ${DATE}</span>.</p>
<table cellspacing="0" class="TableStyle-NoteTable_Yellow_DoNotEdit" oldrole="warning" style="width: 100%;mc-table-style: url('../../Resources/TableStyles/NoteTable_Yellow_DoNotEdit.css');"><col class="TableStyle-NoteTable_Yellow_DoNotEdit-Column-Column1" style="width: 0.3in;"></col><col class="TableStyle-NoteTable_Yellow_DoNotEdit-Column-Column2"></col><tbody><tr class="TableStyle-NoteTable_Yellow_DoNotEdit-Body-Body1"><td class="TableStyle-NoteTable_Yellow_DoNotEdit-BodyB-Column1-Body1"><p><img src="../../Resources/Images/Common/caution.png"/></p></td><td class="TableStyle-NoteTable_Yellow_DoNotEdit-BodyA-Column2-Body1"><span class="Yellow">Caution: </span><p oldrole="para">When referencing an earlier message of the context, always enclose the field name between braces, for example, <span class="Code" oldrole="userinput">${PID}@3</span>. The reference will not work if you omit the braces.</p></td></tr></tbody></table>
<MadCap:snippetBlock src="../../shared/wnt/note-escape-at.htm"></MadCap:snippetBlock>
<MadCap:snippetBlock src="../../shared/chunk/example-grouping-by-referencing-earlier-values.htm"></MadCap:snippetBlock>
<p oldrole="para">If you do not know in which message of the context contains the information you need, you can use the <span class="Code" oldrole="parameter">grep</span> template function. For details, see <xref linkend="template-function-grep"></xref>.</p>
<MadCap:snippetBlock src="../../shared/chunk/example-grep-template-function.htm"></MadCap:snippetBlock>
<p oldrole="para">To perform calculations on fields that have numerical values, see <xref linkend="template-function-numerical"></xref>.</p>


<h2 name="grouping-by-parser-options">Options of <span class="Code" oldrole="userinput">grouping-by</span> parsers</h2>
<p oldrole="para">The <span class="Code" oldrole="parameter">grouping-by</span> has the following options.</p>
<simplesect xml:id="grouping-by-parser-aggregate">
<title>aggregate()</title>
<indexterm>
<primary>aggregate()</primary>
</indexterm>
<indexterm>
<primary>grouping-by()</primary>
<secondary>aggregate()</secondary>
</indexterm>
<informaltable colsep="0" frame="topbot" rowsep="0">
<tgroup cols="2">
<colspec colnum="1" colwidth="50pt"></colspec>
<tbody>
<row>
<entry>Synopsis: 
                                 </entry>
<entry>aggregate()</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<p oldrole="para"><i oldrole="emphasis" role="bold">Description:</i> Specifies the message that <entity>abbrev</entity> generates when the context is closed. This option is mandatory.</p>
<p oldrole="para">Note that the <span class="Code" oldrole="parameter">aggregate()</span> option has access to every message of the context, and has the following options:</p>
<ul oldrole="itemizedlist">
<li oldrole="listitem">
<indexterm type="parameter">
<primary>inherit-mode()</primary>
</indexterm>
<MadCap:snippetBlock src="../../shared/chunk/option-inherit-mode.htm"></MadCap:snippetBlock>
<p oldrole="para">The default value of <span class="Code" oldrole="parameter">inherit-mode()</span> is <span class="Code" oldrole="parameter">context</span>.</p>
<p oldrole="para">For details on the message context, see <xref linkend="grouping-by-parser"></xref>.</p>
</li>
<li oldrole="listitem">
<indexterm type="parameter">
<primary>tags()</primary>
</indexterm>
<p oldrole="para"><i oldrole="emphasis">tags</i>: Adds the specified tag to the list of tags.</p>
</li>
<li oldrole="listitem">
<indexterm type="parameter">
<primary>value()</primary>
</indexterm>
<p oldrole="para"><i oldrole="emphasis">value</i>: Adds a name-value pair to the generated message. You can include text, macros, template functions, and you can also reference every message of the context. For details on accessing other messages of the context, see <xref linkend="referencing-previous-messages-grouping-by"></xref>.</p>
</li>
</ul>
</simplesect>
<simplesect xml:id="grouping-by-parser-having">
<title>having()</title>
<indexterm>
<primary>having()</primary>
</indexterm>
<indexterm>
<primary>grouping-by()</primary>
<secondary>having()</secondary>
</indexterm>
<informaltable colsep="0" frame="topbot" rowsep="0">
<tgroup cols="2">
<colspec colnum="1" colwidth="50pt"></colspec>
<tbody>
<row>
<entry>Synopsis: 
                                 </entry>
<entry>having()</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<p oldrole="para"><i oldrole="emphasis" role="bold">Description:</i> Specifies a filter: <entity>abbrev</entity> generates the aggregate message only if the result of the filter expression is true. Note that the <span class="Code" oldrole="parameter">having()</span> filter has access to every message of the context. For details on accessing other messages of the context, see <xref linkend="referencing-previous-messages-grouping-by"></xref>.</p>
</simplesect>
<simplesect xml:id="grouping-by-parser-inject-mode">
<title>inject-mode()</title>
<indexterm>
<primary>inject-mode()</primary>
</indexterm>
<indexterm>
<primary>grouping-by()</primary>
<secondary>inject-mode()</secondary>
</indexterm>
<informaltable colsep="0" frame="topbot" rowsep="0">
<tgroup cols="2">
<colspec colnum="1" colwidth="50pt"></colspec>
<tbody>
<row>
<entry>Synopsis: 
                                 </entry>
<entry>inject-mode()</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<p oldrole="para"><i oldrole="emphasis" role="bold">Description:</i> By default, the aggregated message that <entity>abbrev</entity> generates is injected into the same place where the <span class="Code" oldrole="parameter">grouping-by()</span> statement is referenced in the log path. To post the generated message into the <span class="Code" oldrole="parameter">internal()</span> source instead, use the <span class="Code" oldrole="parameter">inject-mode()</span> option in the definition of the parser.</p>
<example>
<title>Sending triggered messages to the <span class="Code" oldrole="parameter">internal()</span> source</title>
<p oldrole="para">To send the generated messages to the <span class="Code" oldrole="parameter">internal</span> source, use the <span class="Code" oldrole="userinput">inject-mode("internal")</span> option:</p>
<pre class="Code" oldrole="synopsis">parser p_grouping-by {grouping-by(
    ...
    inject-mode("internal")
);};</pre>
<p oldrole="para">To inject the generated messages where the parser is referenced, use the <span class="Code" oldrole="userinput">inject-mode("pass-through")</span> option:</p>
<pre class="Code" oldrole="synopsis">parser p_grouping-by {grouping-by(
    ...
    inject-mode("pass-through")
);};</pre>
</example>
<p oldrole="para">You can configure the generated message in the <span class="Code" oldrole="parameter">aggregate()</span> option (see <xref linkend="grouping-by-parser-aggregate"></xref>). You can create an entire message, use macros and values extracted from the original message, and so on.</p>
</simplesect>
<simplesect xml:id="grouping-by-parser-key">
<title>key()</title>
<indexterm>
<primary>key()</primary>
</indexterm>
<indexterm>
<primary>grouping-by()</primary>
<secondary>key()</secondary>
</indexterm>
<informaltable colsep="0" frame="topbot" rowsep="0">
<tgroup cols="2">
<colspec colnum="1" colwidth="50pt"></colspec>
<tbody>
<row>
<entry>Synopsis: 
                                 </entry>
<entry>key()</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<p oldrole="para"><i oldrole="emphasis" role="bold">Description:</i> Specifies the key as a template (that is, the name of a name-value pair) that every message must have to be added to the context. The value of the key must be the same for every message of the context. For example, this can be a session-id parsed from firewall messages, and so on.</p>
<p oldrole="para">This is a mandatory option.</p>
<table cellspacing="0" class="TableStyle-NoteTable_Blue_DoNotEdit" oldrole="note" style="width: 100%;mc-table-style: url('../../Resources/TableStyles/NoteTable_Blue_DoNotEdit.css');"><col class="TableStyle-NoteTable_Blue_DoNotEdit-Column-Column1" style="width: 0.3in;"></col><col class="TableStyle-NoteTable_Blue_DoNotEdit-Column-Column2"></col><tbody><tr class="TableStyle-NoteTable_Blue_DoNotEdit-Body-Body1"><td class="TableStyle-NoteTable_Blue_DoNotEdit-BodyB-Column1-Body1"><p><img src="../../Resources/Images/Common/note.png"/></p></td><td class="TableStyle-NoteTable_Blue_DoNotEdit-BodyA-Column2-Body1"><span class="AllNoteStyles">NOTE: </span><p oldrole="para">Messages that do not have a key will all belong to the same context.</p></td></tr></tbody></table>
<table cellspacing="0" class="TableStyle-NoteTable_Blue_DoNotEdit" oldrole="note" style="width: 100%;mc-table-style: url('../../Resources/TableStyles/NoteTable_Blue_DoNotEdit.css');"><col class="TableStyle-NoteTable_Blue_DoNotEdit-Column-Column1" style="width: 0.3in;"></col><col class="TableStyle-NoteTable_Blue_DoNotEdit-Column-Column2"></col><tbody><tr class="TableStyle-NoteTable_Blue_DoNotEdit-Body-Body1"><td class="TableStyle-NoteTable_Blue_DoNotEdit-BodyB-Column1-Body1"><p><img src="../../Resources/Images/Common/note.png"/></p></td><td class="TableStyle-NoteTable_Blue_DoNotEdit-BodyA-Column2-Body1"><span class="AllNoteStyles">NOTE: </span><p oldrole="para">If the value of the key is static (for example, key("PROGRAM") instead of key("$PROGRAM")), all messages will belong to the same context.</p></td></tr></tbody></table>
</simplesect>
<simplesect xml:id="grouping-by-parser-scope">
<title>scope()</title>
<indexterm>
<primary>scope()</primary>
</indexterm>
<indexterm>
<primary>grouping-by()</primary>
<secondary>scope()</secondary>
</indexterm>
<informaltable colsep="0" frame="topbot" rowsep="0">
<tgroup cols="2">
<colspec colnum="1" colwidth="50pt"></colspec>
<tbody>
<row>
<entry>Synopsis: 
                                 </entry>
<entry>scope()</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<p oldrole="para"><i oldrole="emphasis" role="bold">Description:</i> Specifies which messages belong to the same context. The following values are available:</p>
<ul oldrole="itemizedlist" version="5.0">
<li oldrole="listitem">
<indexterm type="parameter">
<primary>process <entity>mdash</entity> scope</primary>
</indexterm>
<p oldrole="para"><i oldrole="emphasis">process</i>: Only messages that are generated by the same process of a client belong to the same context, that is, messages that have identical ${HOST}, ${PROGRAM} and ${PID} values.</p>
</li>
<li oldrole="listitem">
<indexterm type="parameter">
<primary>program <entity>mdash</entity> scope</primary>
</indexterm>
<p oldrole="para"><i oldrole="emphasis">program</i>: Messages that are generated by the same application of a client belong to the same context, that is, messages that have identical ${HOST} and ${PROGRAM} values.</p>
</li>
<li oldrole="listitem">
<indexterm type="parameter">
<primary>host <entity>mdash</entity> scope</primary>
</indexterm>
<p oldrole="para"><i oldrole="emphasis">host</i>: Every message generated by a client belongs to the same context, only the ${HOST} value of the messages must be identical.</p>
</li>
<li oldrole="listitem">
<indexterm type="parameter">
<primary>global <entity>mdash</entity> scope</primary>
</indexterm>
<p oldrole="para"><i oldrole="emphasis">global</i>: Every message belongs to the same context. This is the default value.</p>
</li>
</ul>
</simplesect>
<simplesect xml:id="grouping-by-parser-timeout">
<title>timeout()</title>
<indexterm>
<primary>timeout()</primary>
</indexterm>
<indexterm>
<primary>grouping-by()</primary>
<secondary>timeout()</secondary>
</indexterm>
<informaltable colsep="0" frame="topbot" rowsep="0">
<tgroup cols="2">
<colspec colnum="1" colwidth="50pt"></colspec>
<tbody>
<row>
<entry>Synopsis: 
                                 </entry>
<entry>timeout([seconds])</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<p oldrole="para"><i oldrole="emphasis" role="bold">Description:</i> Specifies the maximum time to wait for all messages of the context to arrive. If no new message is added to the context during this period, the context is assumed to be complete and <entity>abbrev</entity> generates and sends the triggered message (specified in the <a href="parser-grouping-by.htm">aggregate()</a> option), and clears the context. If a new message is added to the context, the timeout period is restarted.</p>
<p oldrole="para">This option is mandatory, and its value must be equal to or greater than <span class="Code" oldrole="userinput">1</span>.</p>
</simplesect>
<simplesect xml:id="grouping-by-parser-trigger">
<title>trigger()</title>
<indexterm>
<primary>trigger()</primary>
</indexterm>
<indexterm>
<primary>grouping-by()</primary>
<secondary>trigger()</secondary>
</indexterm>
<informaltable colsep="0" frame="topbot" rowsep="0">
<tgroup cols="2">
<colspec colnum="1" colwidth="50pt"></colspec>
<tbody>
<row>
<entry>Synopsis: 
                                 </entry>
<entry>trigger()</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<p oldrole="para"><i oldrole="emphasis" role="bold">Description:</i> A filter that specifies the final message of the context. If the filter matches the incoming message, <entity>abbrev</entity> generates and sends the triggered message (specified in the <a href="parser-grouping-by.htm">aggregate()</a> option), and clears the context.</p>
</simplesect>
<simplesect xml:id="grouping-by-parser-where">
<title>where()</title>
<indexterm>
<primary>where()</primary>
</indexterm>
<indexterm>
<primary>grouping-by()</primary>
<secondary>where()</secondary>
</indexterm>
<informaltable colsep="0" frame="topbot" rowsep="0">
<tgroup cols="2">
<colspec colnum="1" colwidth="50pt"></colspec>
<tbody>
<row>
<entry>Synopsis: 
                                 </entry>
<entry>where()</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<p oldrole="para"><i oldrole="emphasis" role="bold">Description:</i> Specifies a filter condition. Messages not matching the filter will not be added to the context. Note that the <span class="Code" oldrole="parameter">where()</span> filter has access only to the current message.</p>
</simplesect>

</body></html>
