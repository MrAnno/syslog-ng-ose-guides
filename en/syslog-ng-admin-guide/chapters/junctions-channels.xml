<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section SYSTEM "../../xml-stylesheet/pdf/dtd/docbookx.dtd"
 [  <!ENTITY % entities SYSTEM "../syslog-ng-entities.ent">
 %entities;]>
<section id="junctions">
    <title>Junctions and channels</title>
    <indexterm>
        <primary>junctions</primary>
    </indexterm>
    <indexterm type="parameter" significance="preferred">
        <primary>junction</primary>
    </indexterm>
    <indexterm type="parameter">
        <primary>channel</primary>
    </indexterm>
    <para>Junctions make it possible to send the messages to different channels, process the messages differently on each channel, and then join every channel together again. You can define any number of channels in a junction: every channel receives a copy of every message that reaches the junction. Every channel can process the messages differently, and at the end of the junction, the processed messages of every channel return to the junction again, where further processing is possible.</para>
    <para>A junction includes one or more channels. A channel usually includes at least one filter, though that is not enforced. Otherwise, channels are identical to log statements, and can include any kind of objects, for example, parsers, rewrite rules, destinations, and so on. (For details on using channels, as well as on using channels outside junctions, see <xref linkend="embedded-objects"/>.)</para>
    <note>
        <para>Certain parsers can also act as filters:</para>
        <itemizedlist>
            <listitem>
                <para>The JSON parser automatically discards messages that are not valid JSON messages.</para>
            </listitem>
            <listitem>
                <para>The <parameter>csv-parser()</parameter> discards invalid messages if the <parameter>flags(drop-invalid)</parameter> option is set.</para>
            </listitem>
        </itemizedlist>
    </note>
    <para>You can also use log-path flags in the channels of the junction. Within the junction, a message is processed by every channel, in the order the channels appear in the configuration file. Typically if your channels have filters, you also set the <parameter>flags(final)</parameter> option for the channel. However, note that the log-path flags of the channel apply only within the junction, for example, if you set the <parameter>final</parameter> flag for a channel, then the subsequent channels of the junction will not receive the message, but this does not affect any other log path or junction of the configuration. The only exception is the <parameter>flow-control</parameter> flag: if you enable flow-control in a junction, it affects the entire log path. For details on log-path flags, see <xref linkend="reference_logflags"/>.</para>
    <synopsis>junction {
    channel { &lt;other-syslog-ng-objects&gt; &lt;log-path-flags&gt;}
    channel { &lt;other-syslog-ng-objects&gt; &lt;log-path-flags&gt;}
    ...
    }</synopsis>
    <example id="example-junctions">
        <title>Using junctions</title>
        <para>For example, suppose that you have a single network source that receives log messages from different devices, and some devices send messages that are not RFC-compliant (some routers are notorious for that). To solve this problem in earlier versions of &abbrev;, you had to create two different network sources using different IP addresses or ports: one that received the RFC-compliant messages, and one that received the improperly formatted messages (for example, using the <parameter>flags(no-parse)</parameter> option). Using junctions this becomes much more simple: you can use a single network source to receive every message, then use a junction and two channels. The first channel processes the RFC-compliant messages, the second everything else. At the end, every message is stored in a single file. The filters used in the example can be <parameter>host()</parameter> filters (if you have a list of the IP addresses of the devices sending non-compliant messages), but that depends on your environment.</para>
        <synopsis>log {
    source s_network { syslog(ip(10.1.2.3) transport("tcp")); flags(no-parse); };
    junction {
        channel { filter(f_compliant_hosts); parser { syslog-parser(); }; };
        channel { filter(f_noncompliant_hosts); };
    };
    destination { file("/var/log/messages"); };
};</synopsis>
    <para>Since every channel receives every message that reaches the junction, use the <parameter>flags(final)</parameter> option in the channels to avoid the unnecessary processing the messages multiple times:</para>
    <synopsis>log {
    source s_network { syslog(ip(10.1.2.3) transport("tcp")); flags(no-parse); };
    junction {
        channel { filter(f_compliant_hosts); parser { syslog-parser(); }; flags(final); };
        channel { filter(f_noncompliant_hosts); flags(final); };
    };
    destination { file("/var/log/messages"); };
};</synopsis>
    </example>
    <note>
        <para>Junctions differ from embedded log statements, because embedded log statements are like branches: they split the flow of messages into separate paths, and the different paths do not meet again. Messages processed on different embedded log statements cannot be combined together for further processing. However, junctions split the messages to channels, then combine the channels together.</para>
    </note>
<!--
    FIXME abra
-->
</section>
