<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section SYSTEM "../../xml-stylesheet/pdf/dtd/docbookx.dtd"
 [  <!ENTITY % entities SYSTEM "../syslog-ng-entities.ent">
 %entities;]>
<section id="junctions">
    <title>Junctions and channels</title>
    <para>Junctions make it possible to split the messages to different channels, process the messages differently on each channel, and then join every channel together again. You can define any number of channels in a junction: every channel receives a copy of every message that reaches the junction. Every channel can process the messages differently, and at the end of the junction, the processed messages of every channel return to the junction again, where further processing is possible.</para>
    <para>A junction includes one or more channels. A channel usually includes at least one filter, though that is not enforced. Otherwise, channels are identical to log statements, and can include any kind of objects, for example, parsers, rewrite rules, destinations, and so on.</para>
    <synopsis>junction {
    channel { &lt;other-syslog-ng-objects&gt; &lt;log-path-flags&gt;}
    channel { &lt;other-syslog-ng-objects&gt; &lt;log-path-flags&gt;}
    ...
    }</synopsis>
    <example>
        <title>Using junctions</title>
        <para>For example, suppose that you have a single network source that receives log messages from different devices, and some devices send messages that are not RFC-compliant (some routers are notorious for that). To solve this problem in earlier versions of &abbrev;, you had to create two different network sources using different IP addresses or ports: one that received the RFC-compliant messages, and one that received the improperly formatted messages (for example, using the <parameter>flags(no-parse)</parameter> option). Using junctions this becomes much more simple: you can use a single network source to receive every message, then use a junction and two channels. The first channel processes the RFC-compliant messages, the second everything else. At the end, every message is stored in a single file. The filters used in the example can be <parameter>host()</parameter> filters (if you have a list of the IP addresses of the devices sending non-compliant messages), but that depends on your environment.</para>
        <synopsis>log {
    source s_network { syslog(ip(10.1.2.3) transport("tcp")); flags(no-parse); };
    junction {
        channel { filter(f_compliant_hosts); parser { syslog-parser(); }; };
        channel { filter(f_noncompliant_hosts); };
    };
    destination { file("/var/log/messages"); };
};</synopsis>
    </example>
    <note>
        <para>Junctions differ from embedded log statements, because embedded log statements are like branches: they split the flow of messages into separate paths, and the different paths do not meet again. Messages processed on different embedded log statements cannot be combined together for further processing. However, junctions split the messages to channels, then combine the channels together.</para>
    </note>
<!--
    FIXME abra
-->
</section>
